{"version":3,"file":"urql.es.js","sources":["../src/context.ts","../src/hooks/state.ts","../src/hooks/useMutation.ts","../src/hooks/useRequest.ts","../src/hooks/useQuery.ts","../src/hooks/cache.ts","../src/hooks/useSubscription.ts","../src/components/Mutation.ts","../src/components/Query.ts","../src/components/Subscription.ts"],"sourcesContent":["import { createContext, useContext } from 'react';\nimport { Client, createClient } from '@urql/core';\n\n// We assume some default options here; mainly not to actually be used\n// but not to error catastrophically if someone is just playing around\nconst defaultClient = createClient({ url: '/graphql' });\n\nexport const Context = createContext<Client>(defaultClient);\nexport const Provider = Context.Provider;\nexport const Consumer = Context.Consumer;\nContext.displayName = 'UrqlContext';\n\nlet hasWarnedAboutDefault = false;\n\nexport const useClient = (): Client => {\n  const client = useContext(Context);\n\n  if (\n    process.env.NODE_ENV !== 'production' &&\n    client === defaultClient &&\n    !hasWarnedAboutDefault\n  ) {\n    hasWarnedAboutDefault = true;\n\n    console.warn(\n      \"Default Client: No client has been specified using urql's Provider.\" +\n        'This means that urql will be falling back to defaults including making ' +\n        'requests to `/graphql`.\\n' +\n        \"If that's not what you want, please create a client and add a Provider.\"\n    );\n  }\n\n  return client;\n};\n","export const initialState = {\n  fetching: false,\n  stale: false,\n  error: undefined,\n  data: undefined,\n  extensions: undefined,\n  operation: undefined,\n};\n\nconst isShallowDifferent = (a: any, b: any) => {\n  if (typeof a != 'object' || typeof b != 'object') return a !== b;\n  for (const x in a) if (!(x in b)) return true;\n  for (const x in b) if (a[x] !== b[x]) return true;\n  return false;\n};\n\ninterface Stateish {\n  data?: any;\n  error?: any;\n  fetching: boolean;\n  stale: boolean;\n}\n\nexport const computeNextState = <T extends Stateish>(\n  prevState: T,\n  result: Partial<T>\n): T => {\n  const newState = {\n    ...prevState,\n    ...result,\n    data:\n      result.data !== undefined || result.error ? result.data : prevState.data,\n    fetching: !!result.fetching,\n    stale: !!result.stale,\n  };\n\n  return isShallowDifferent(prevState, newState) ? newState : prevState;\n};\n\nexport const hasDepsChanged = <T extends { length: number }>(a: T, b: T) => {\n  for (let i = 0, l = b.length; i < l; i++) if (a[i] !== b[i]) return true;\n  return false;\n};\n","import { DocumentNode } from 'graphql';\nimport { useState, useCallback, useRef, useEffect } from 'react';\nimport { pipe, toPromise } from 'wonka';\n\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n  CombinedError,\n  createRequest,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { initialState } from './state';\n\nexport interface UseMutationState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseMutationResponse<Data = any, Variables = object> = [\n  UseMutationState<Data, Variables>,\n  (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>\n];\n\nexport function useMutation<Data = any, Variables = object>(\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string\n): UseMutationResponse<Data, Variables> {\n  const isMounted = useRef(true);\n  const client = useClient();\n\n  const [state, setState] = useState<UseMutationState<Data, Variables>>(\n    initialState\n  );\n\n  const executeMutation = useCallback(\n    (variables?: Variables, context?: Partial<OperationContext>) => {\n      setState({ ...initialState, fetching: true });\n\n      return pipe(\n        client.executeMutation<Data, Variables>(\n          createRequest<Data, Variables>(query, variables),\n          context || {}\n        ),\n        toPromise\n      ).then(result => {\n        if (isMounted.current) {\n          setState({\n            fetching: false,\n            stale: !!result.stale,\n            data: result.data,\n            error: result.error,\n            extensions: result.extensions,\n            operation: result.operation,\n          });\n        }\n        return result;\n      });\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [client, query, setState]\n  );\n\n  useEffect(() => {\n    isMounted.current = true;\n    return () => {\n      isMounted.current = false;\n    };\n  }, []);\n\n  return [state, executeMutation];\n}\n","import { DocumentNode } from 'graphql';\nimport { useRef, useMemo } from 'react';\nimport { TypedDocumentNode, GraphQLRequest, createRequest } from '@urql/core';\n\n/** Creates a request from a query and variables but preserves reference equality if the key isn't changing */\nexport function useRequest<Data = any, Variables = object>(\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>,\n  variables?: Variables\n): GraphQLRequest<Data, Variables> {\n  const prev = useRef<undefined | GraphQLRequest<Data, Variables>>(undefined);\n\n  return useMemo(() => {\n    const request = createRequest<Data, Variables>(query, variables);\n    // We manually ensure reference equality if the key hasn't changed\n    if (prev.current !== undefined && prev.current.key === request.key) {\n      return prev.current;\n    } else {\n      prev.current = request;\n      return request;\n    }\n  }, [query, variables]);\n}\n","/* eslint-disable react-hooks/exhaustive-deps */\nimport { DocumentNode } from 'graphql';\nimport { Source, pipe, subscribe, takeWhile } from 'wonka';\nimport { useCallback, useMemo, useState } from 'react';\nimport { useSyncExternalStore } from 'use-sync-external-store/shim';\nimport {\n  Client,\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  RequestPolicy,\n  OperationResult,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { hasDepsChanged, computeNextState, initialState } from './state';\nimport { getCacheForClient } from './cache';\n\nexport interface UseQueryArgs<Variables = object, Data = any> {\n  query: string | DocumentNode | TypedDocumentNode<Data, Variables>;\n  variables?: Variables;\n  requestPolicy?: RequestPolicy;\n  context?: Partial<OperationContext>;\n  pause?: boolean;\n}\n\nexport interface UseQueryState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseQueryResponse<Data = any, Variables = object> = [\n  UseQueryState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nconst notFetching = initialState;\nconst fetching = { ...initialState, fetching: true };\n\nconst isSuspense = (client: Client, context?: Partial<OperationContext>) =>\n  client.suspense && (!context || context.suspense !== false);\n\nexport function useQuery<Data = any, Variables = object>(\n  args: UseQueryArgs<Variables, Data>\n): UseQueryResponse<Data, Variables> {\n  const client = useClient();\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n  const cache = getCacheForClient(client);\n\n  const currDeps: unknown[] = [\n    client,\n    request,\n    args.pause,\n    args.requestPolicy,\n    args.context,\n  ];\n\n  const [meta, setMeta] = useState<{\n    source: Source<OperationResult<Data, Variables>> | null;\n    prevValue: UseQueryState<Data, Variables>;\n    deps: unknown[];\n    suspense: boolean;\n  }>(() => ({\n    source: args.pause\n      ? null\n      : client.executeQuery(request, {\n          requestPolicy: args.requestPolicy,\n          ...args.context,\n        }),\n    prevValue: notFetching,\n    deps: currDeps,\n    suspense: isSuspense(client, args.context),\n  }));\n\n  const { source, deps, suspense } = meta;\n\n  const [getSnapshot, sub] = useMemo(() => {\n    let result = cache.get(request.key);\n\n    const getSnapshot = (): Partial<UseQueryState<Data, Variables>> => {\n      if (!source) {\n        return notFetching;\n      } else if (!result) {\n        let resolve:\n          | ((result: OperationResult<Data, Variables>) => void)\n          | undefined;\n\n        const subscription = pipe(\n          source,\n          takeWhile(\n            () =>\n              (suspense && (!resolve || (result && (result as any).then))) ||\n              !result\n          ),\n          subscribe(_result => {\n            result = _result;\n            if (suspense) {\n              cache.set(request.key, result);\n            }\n\n            if (resolve) {\n              resolve(result);\n              resolve = undefined;\n            }\n          })\n        );\n\n        if (result == null && suspense) {\n          const promise = (result = new Promise(_resolve => {\n            resolve = _resolve;\n          }));\n          cache.set(request.key, promise);\n          throw promise;\n        } else {\n          subscription.unsubscribe();\n        }\n      } else if (suspense && result != null && 'then' in result) {\n        throw result;\n      }\n\n      return (result as OperationResult<Data, Variables>) || fetching;\n    };\n\n    const sub = (notify: () => void) => {\n      if (!source) {\n        return () => {\n          /*noop*/\n        };\n      }\n\n      const unsub = pipe(\n        source,\n        subscribe(_result => {\n          result = _result;\n          if (suspense) {\n            cache.set(request.key, result);\n          }\n          notify();\n        })\n      ).unsubscribe;\n\n      return () => {\n        cache.dispose(request.key);\n        unsub();\n      };\n    };\n\n    return [getSnapshot, sub];\n  }, [source, args.pause]);\n\n  const executeQuery = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const context = {\n        requestPolicy: args.requestPolicy,\n        ...args.context,\n        ...opts,\n      };\n\n      setMeta(prev => ({\n        prevValue: prev.prevValue,\n        deps: prev.deps,\n        source: client.executeQuery(request, context),\n        suspense: isSuspense(client, context),\n      }));\n    },\n    [client, request, args.requestPolicy, args.context]\n  );\n\n  const result = (meta.prevValue = computeNextState(\n    meta.prevValue,\n    useSyncExternalStore<Partial<UseQueryState<Data, Variables>>>(\n      sub,\n      getSnapshot,\n      getSnapshot\n    )\n  ));\n\n  if (hasDepsChanged(deps, currDeps) && !args.pause) {\n    setMeta({\n      prevValue: result,\n      source: args.pause\n        ? null\n        : client.executeQuery(request, {\n            requestPolicy: args.requestPolicy,\n            ...args.context,\n          }),\n      deps: currDeps,\n      suspense: isSuspense(client, args.context),\n    });\n  }\n\n  return [result, executeQuery];\n}\n","import { pipe, subscribe } from 'wonka';\nimport { Client, OperationResult } from '@urql/core';\n\ntype CacheEntry = OperationResult | Promise<unknown> | undefined;\n\ninterface Cache {\n  get(key: number): CacheEntry;\n  set(key: number, value: CacheEntry): void;\n  dispose(key: number): void;\n}\n\ninterface ClientWithCache extends Client {\n  _react?: Cache;\n}\n\nexport const getCacheForClient = (client: Client): Cache => {\n  if (!(client as ClientWithCache)._react) {\n    const reclaim = new Set();\n    const map = new Map<number, CacheEntry>();\n\n    if (client.operations$ /* not available in mocks */) {\n      pipe(\n        client.operations$,\n        subscribe(operation => {\n          if (operation.kind === 'teardown' && reclaim.has(operation.key)) {\n            reclaim.delete(operation.key);\n            map.delete(operation.key);\n          }\n        })\n      );\n    }\n\n    (client as ClientWithCache)._react = {\n      get(key) {\n        return map.get(key);\n      },\n      set(key, value) {\n        reclaim.delete(key);\n        map.set(key, value);\n      },\n      dispose(key) {\n        reclaim.add(key);\n      },\n    };\n  }\n\n  return (client as ClientWithCache)._react!;\n};\n","/* eslint-disable react-hooks/exhaustive-deps */\n\nimport { DocumentNode } from 'graphql';\nimport { pipe, subscribe, onEnd } from 'wonka';\nimport { useEffect, useState, useCallback, useMemo, useRef } from 'react';\n\nimport {\n  TypedDocumentNode,\n  CombinedError,\n  OperationContext,\n  Operation,\n} from '@urql/core';\n\nimport { useClient } from '../context';\nimport { useRequest } from './useRequest';\nimport { initialState, computeNextState, hasDepsChanged } from './state';\n\nexport interface UseSubscriptionArgs<Variables = object, Data = any> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  variables?: Variables;\n  pause?: boolean;\n  context?: Partial<OperationContext>;\n}\n\nexport type SubscriptionHandler<T, R> = (prev: R | undefined, data: T) => R;\n\nexport interface UseSubscriptionState<Data = any, Variables = object> {\n  fetching: boolean;\n  stale: boolean;\n  data?: Data;\n  error?: CombinedError;\n  extensions?: Record<string, any>;\n  operation?: Operation<Data, Variables>;\n}\n\nexport type UseSubscriptionResponse<Data = any, Variables = object> = [\n  UseSubscriptionState<Data, Variables>,\n  (opts?: Partial<OperationContext>) => void\n];\n\nexport function useSubscription<Data = any, Result = Data, Variables = object>(\n  args: UseSubscriptionArgs<Variables, Data>,\n  handler?: SubscriptionHandler<Data, Result>\n): UseSubscriptionResponse<Result, Variables> {\n  const client = useClient();\n  const request = useRequest<Data, Variables>(args.query, args.variables);\n\n  const handlerRef = useRef<SubscriptionHandler<Data, Result> | undefined>(\n    handler\n  );\n  handlerRef.current = handler;\n\n  const source = useMemo(\n    () =>\n      !args.pause ? client.executeSubscription(request, args.context) : null,\n    [client, request, args.pause, args.context]\n  );\n\n  const deps = [client, request, args.context, args.pause] as const;\n\n  const [state, setState] = useState(\n    () => [source, { ...initialState, fetching: !!source }, deps] as const\n  );\n\n  let currentResult = state[1];\n  if (source !== state[0] && hasDepsChanged(state[2], deps)) {\n    setState([\n      source,\n      (currentResult = computeNextState(state[1], { fetching: !!source })),\n      deps,\n    ]);\n  }\n\n  useEffect(() => {\n    const updateResult = (\n      result: Partial<UseSubscriptionState<Data, Variables>>\n    ) => {\n      setState(state => {\n        const nextResult = computeNextState(state[1], result);\n        if (state[1] === nextResult) return state;\n        if (handlerRef.current && state[1].data !== nextResult.data) {\n          nextResult.data = handlerRef.current(\n            state[1].data,\n            nextResult.data!\n          ) as any;\n        }\n\n        return [state[0], nextResult as any, state[2]];\n      });\n    };\n\n    if (state[0]) {\n      return pipe(\n        state[0],\n        onEnd(() => {\n          updateResult({ fetching: false });\n        }),\n        subscribe(updateResult)\n      ).unsubscribe;\n    } else {\n      updateResult({ fetching: false });\n    }\n  }, [state[0]]);\n\n  // This is the imperative execute function passed to the user\n  const executeSubscription = useCallback(\n    (opts?: Partial<OperationContext>) => {\n      const source = client.executeSubscription(request, {\n        ...args.context,\n        ...opts,\n      });\n\n      setState(state => [source, state[1], state[2]]);\n    },\n    [client, args.context, request]\n  );\n\n  return [currentResult, executeSubscription];\n}\n","import { DocumentNode } from 'graphql';\nimport { ReactElement } from 'react';\nimport {\n  TypedDocumentNode,\n  OperationResult,\n  OperationContext,\n} from '@urql/core';\nimport { useMutation, UseMutationState } from '../hooks';\n\nexport interface MutationProps<Data = any, Variables = object> {\n  query: DocumentNode | TypedDocumentNode<Data, Variables> | string;\n  children: (arg: MutationState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface MutationState<Data = any, Variables = object>\n  extends UseMutationState<Data, Variables> {\n  executeMutation: (\n    variables?: Variables,\n    context?: Partial<OperationContext>\n  ) => Promise<OperationResult<Data, Variables>>;\n}\n\nexport function Mutation<Data = any, Variables = any>(\n  props: MutationProps<Data, Variables>\n): ReactElement<any> {\n  const mutation = useMutation<Data, Variables>(props.query);\n  return props.children({ ...mutation[0], executeMutation: mutation[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\nimport { useQuery, UseQueryArgs, UseQueryState } from '../hooks';\n\nexport interface QueryProps<Data = any, Variables = object>\n  extends UseQueryArgs<Variables, Data> {\n  children: (arg: QueryState<Data, Variables>) => ReactElement<any>;\n}\n\nexport interface QueryState<Data = any, Variables = object>\n  extends UseQueryState<Data, Variables> {\n  executeQuery: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Query<Data = any, Variables = any>(\n  props: QueryProps<Data, Variables>\n): ReactElement<any> {\n  const query = useQuery<Data, Variables>(props);\n  return props.children({ ...query[0], executeQuery: query[1] });\n}\n","import { ReactElement } from 'react';\nimport { OperationContext } from '@urql/core';\n\nimport {\n  useSubscription,\n  UseSubscriptionArgs,\n  UseSubscriptionState,\n  SubscriptionHandler,\n} from '../hooks';\n\nexport interface SubscriptionProps<\n  Data = any,\n  Result = Data,\n  Variables = object\n> extends UseSubscriptionArgs<Variables, Data> {\n  handler?: SubscriptionHandler<Data, Result>;\n  children: (arg: SubscriptionState<Result, Variables>) => ReactElement<any>;\n}\n\nexport interface SubscriptionState<Data = any, Variables = object>\n  extends UseSubscriptionState<Data, Variables> {\n  executeSubscription: (opts?: Partial<OperationContext>) => void;\n}\n\nexport function Subscription<Data = any, Result = Data, Variables = object>(\n  props: SubscriptionProps<Data, Result, Variables>\n): ReactElement<any> {\n  const subscription = useSubscription<Data, Result, Variables>(\n    props,\n    props.handler\n  );\n\n  return props.children({\n    ...subscription[0],\n    executeSubscription: subscription[1],\n  });\n}\n"],"names":["url","Context","Consumer","let","hasWarnedAboutDefault","fetching","stale","undefined","error","data","extensions","prevState","result","b","hasDepsChanged","a","i","l","length","useMutation","query","isMounted","useRef","client","useClient","useState","initialState","executeMutation","useCallback","variables","context","setState","_extends","toPromise","createRequest","then","current","operation","useEffect","state","useRequest","prev","useMemo","request","key","const","notFetching","isSuspense","suspense","useQuery","args","cache","getCacheForClient","_react","reclaim","Set","map","Map","operations$","subscribe","kind","has","delete","get","set","value","dispose","add","currDeps","pause","requestPolicy","source","executeQuery","prevValue","deps","resolve","subscription","_result","takeWhile","promise","Promise","_resolve","unsubscribe","notify","unsub","opts","setMeta","meta","computeNextState","useSyncExternalStore","sub","getSnapshot","useSubscription","handler","handlerRef","executeSubscription","currentResult","updateResult","nextResult","onEnd","Mutation","props","mutation","children","Query","Subscription"],"mappings":"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"}